version: '3'

services:

  postgres:
    image: postgres:alpine
    restart: on-failure

  rabbitmq:
    image: rabbitmq:alpine
    restart: on-failure

  redis:
    image: redis:alpine
    restart: on-failure

  #
  # This is a temporary container initialised just to setup the database and
  # pre-populate it with some default data.  It exits not long after it starts
  # and can be manually removed afterward.
  #
  setup:
    image: danielquinn/albatross
    depends_on:
      - postgres
    volumes:
      - .:/app
    user: app
    restart: no
    entrypoint: '/bin/sh /app/docker/setup'

  #
  # Celery is the service that's used by the webserver and collector to
  # asynchronously queue up jobs.
  #
  celery:
    image: danielquinn/albatross
    depends_on:
      - postgres
      - rabbitmq
      - redis
      - setup
    volumes:
      - .:/app
    user: app
    working_dir: /app/src
    stop_grace_period: 1m
    restart: on-failure
    entrypoint: 'celery worker --app albatross -l warn'

  #
  # The part that talks to Twitter and pulls down the data.  It's
  # multi-threaded, and I don't recommend scaling this.
  #
  collector:
    image: danielquinn/albatross
    depends_on:
      - postgres
      - rabbitmq
      - redis
      - setup
    volumes:
      - .:/app
    user: app
    stop_grace_period: 1m
    restart: on-failure
    entrypoint: "/app/src/manage.py collector"

  #
  # The webserver interface.  Unless you're making this world-facing, you
  # probably don't need to scale this.
  #
  web:
    image: danielquinn/albatross
    depends_on:
      - postgres
      - redis
      - setup
    volumes:
      - .:/app
    ports:
      - '8000:8000'
    user: app
    stop_grace_period: 1s
    restart: on-failure
    entrypoint: '/app/src/manage.py runserver 0.0.0.0:8000 --insecure'
